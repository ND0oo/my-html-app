<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QtScrcpyæŒ‰é”®æ˜ å°„ç¼–è¾‘å™¨-O2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        /* ================== EVAåˆå·æœºä¸»é¢˜é…è‰² ================== */
        body {
            background: linear-gradient(45deg, #3f6d4e 0%, #734f9a 50%, #3f6d4e 100%);
            background-size: 200% 100%;
            animation: gradientShift 10s ease infinite;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* å·¦ä¾§é”®ç›˜é¢æ¿ */
        .keyboard-panel {
            width: 20%;
            min-width: 280px;
            max-width: 400px;
            background: rgba(29, 26, 47, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            overflow-y: auto;
            border-right: 1px solid rgba(139, 212, 80, 0.2);
            position: relative;
            z-index: 10;
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.5);
        }

        .panel-title {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            color: #965fd4;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-shadow: 0 0 10px rgba(150, 95, 212, 0.5);
        }

        .panel-title::before {
            content: 'ğŸ•¹ï¸';
            font-size: 1.25rem;
        }

        .panel-title.no-icon::before {
            display: none;
        }

        .keyboard-section {
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 0.75rem;
            color: #8bd450;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-shadow: 0 0 5px rgba(139, 212, 80, 0.3);
        }

        .keys-grid {
            display: grid;
            gap: 0.5rem;
            grid-template-columns: repeat(auto-fill, minmax(3.5rem, 1fr));
        }

        .key {
            background: rgba(139, 212, 80, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 212, 80, 0.3);
            border-radius: 8px;
            padding: 0.75rem 0.5rem;
            text-align: center;
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.875rem;
            color: #fff;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .key::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .key:hover::before {
            opacity: 1;
        }

        .key:hover {
            background: rgba(139, 212, 80, 0.2);
            border-color: rgba(139, 212, 80, 0.5);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
        }

        .key.dragging {
            opacity: 0.5;
            cursor: grabbing;
            transform: scale(0.9);
        }

        .key.node-type {
            background: linear-gradient(135deg, rgba(150, 95, 212, 0.1) 0%, rgba(150, 95, 212, 0.05) 100%);
            border-color: rgba(150, 95, 212, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .key.node-type .icon {
            font-size: 1.25rem;
        }

        .key.node-type .label {
            font-size: 0.625rem;
            opacity: 0.7;
        }

        /* ä¸­é—´ç”»å¸ƒåŒºåŸŸ */
        .canvas-area {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, rgba(15, 15, 15, 0.6) 0%, rgba(0, 0, 0, 0.6) 100%);
            overflow: hidden;
        }

        .canvas-container {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(29, 26, 47, 0.95);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            border: 1px solid rgba(150, 95, 212, 0.2);
            transform-origin: center center;
        }

        #deviceCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        #backgroundImage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0.4;
            z-index: 0;
        }

        /* æ˜ å°„é”®æ ·å¼ */
        .mapped-key {
            position: absolute;
            background: rgba(150, 95, 212, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid #965fd4;
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            z-index: 10; /* æ™®é€šæŒ‰é”®å±‚çº§ */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 20px rgba(150, 95, 212, 0.5);
        }

        .mapped-key .key-icon {
            font-size: 1.25rem;
            color: #fff;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .mapped-key.press-key {
            background: rgba(139, 212, 80, 0.2);
            border-color: #8bd450;
            box-shadow: 0 4px 20px rgba(139, 212, 80, 0.5);
        }

        .mapped-key.release-key {
            background: rgba(255, 100, 0, 0.2);
            border-color: rgba(255, 100, 0, 0.8);
            box-shadow: 0 4px 20px rgba(255, 100, 0, 0.5);
        }

        .mapped-key:hover {
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 0 6px 30px rgba(150, 95, 212, 0.8);
            z-index: 11;
        }

        .mapped-key.selected {
            background: rgba(115, 79, 154, 0.3);
            border-color: #734f9a;
            box-shadow: 0 0 0 4px rgba(115, 79, 154, 0.2), 0 6px 30px rgba(115, 79, 154, 0.6);
        }

        .mapped-key.wheel {
            width: 16rem; /* æ‘‡æ†å°ºå¯¸æ”¾å¤§åˆ°16rem */
            height: 16rem;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            z-index: 5; /* æ‘‡æ†å±‚çº§ä½äºæ™®é€šæŒ‰é”® */
        }

        .mapped-key.wheel:hover {
            transform: translate(-50%, -50%) scale(1.1);
            z-index: 6; /* æ‚¬åœæ—¶ç¨å¾®æé«˜å±‚çº§ */
        }

        .mapped-key.view-control {
            width: 5rem;
            height: 5rem;
            background: radial-gradient(circle, rgba(200, 0, 255, 0.15) 0%, rgba(200, 0, 255, 0.05) 100%);
            border-color: rgba(200, 0, 255, 0.8);
        }

        .mapped-key.drag-point {
            background: rgba(255, 0, 110, 0.25);
            border-color: rgba(255, 0, 110, 0.8);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.5);
        }

        .mapped-key.directional-cast {
            background: radial-gradient(circle, rgba(255, 0, 110, 0.3) 0%, transparent 70%);
            border: 2px solid #ff006e;
            animation: castPulse 1.5s ease-in-out infinite;
            border-radius: 50%;
            width: 5rem;
            height: 5rem;
        }

        @keyframes castPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        }

        /* è¿æ¥çº¿ */
        .connection-line {
            position: absolute;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            fill: none;
            pointer-events: none;
            z-index: 5;
            animation: dash 1s linear infinite;
        }

        .drag-mapping-line {
            stroke: #8bd450;
            stroke-width: 3;
            filter: drop-shadow(0 0 10px #8bd450);
            animation: dragFlow 1s linear infinite;
            stroke-dasharray: 10, 5;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }

        @keyframes dragFlow {
            to { stroke-dashoffset: -20; }
        }

        /* åˆ é™¤æŒ‰é’® */
        .delete-btn {
            position: absolute;
            top: -0.75rem;
            right: -0.75rem;
            width: 1.5rem;
            height: 1.5rem;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border: 2px solid #fff;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.875rem;
            color: #fff;
            z-index: 12;
            box-shadow: 0 2px 8px rgba(255, 0, 0, 0.4);
            transition: all 0.2s;
        }

        .delete-btn:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(255, 0, 0, 0.6);
        }

        .mapped-key:hover .delete-btn {
            display: flex;
        }

        /* å·¥å…·æç¤º */
        .tooltip {
            position: fixed;
            background: #3f6d4e; /* ç»¿è‰²èƒŒæ™¯ */
            color: #fff;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transform: translateY(-5px);
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            max-width: 300px;
        }

        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 4px solid #3f6d4e; /* ç»¿è‰²ç®­å¤´ */
        }

        .tooltip.bottom::after {
            top: auto;
            bottom: -4px;
            border-bottom: none;
            border-top: 4px solid #3f6d4e; /* ç»¿è‰²ç®­å¤´ */
        }

        /* å³ä¾§å±æ€§é¢æ¿ */
        .properties-panel {
            width: 20%;
            min-width: 250px;
            max-width: 350px;
            background: rgba(29, 26, 47, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-left: 1px solid rgba(139, 212, 80, 0.2);
            overflow-y: auto;
            z-index: 10;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
        }

        .property-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(139, 212, 80, 0.2);
            transition: all 0.3s;
        }

        .property-group:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(139, 212, 80, 0.3);
        }

        .property-label {
            font-size: 0.75rem;
            color: #8bd450;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .property-label .icon {
            font-size: 1rem;
        }

        .property-input {
            width: 100%;
            padding: 0.625rem 0.875rem;
            background: rgba(29, 26, 47, 0.3);
            border: 1px solid rgba(139, 212, 80, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.875rem;
            transition: all 0.3s;
        }

        .property-input:focus {
            outline: none;
            border-color: #8bd450;
            background: rgba(29, 26, 47, 0.5);
            box-shadow: 0 0 0 3px rgba(139, 212, 80, 0.2);
        }

        /* åˆ‡æ¢å¼€å…³ */
        .switch {
            position: relative;
            display: inline-block;
            width: 3rem;
            height: 1.5rem;
            margin-left: auto;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            border-radius: 1rem;
            border: 1px solid rgba(139, 212, 80, 0.3);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 1rem;
            width: 1rem;
            left: 0.25rem;
            bottom: 0.25rem;
            background: #fff;
            transition: all 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #3f6d4e, #8bd450);
            border-color: transparent;
        }

        input:checked + .slider:before {
            transform: translateX(1.5rem);
        }

        /* å·¥å…·æ  */
        .toolbar {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #734f9a, #965fd4); /* ç´«è‰²èƒŒæ™¯ */
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(139, 212, 80, 0.2);
        }

        .tool-btn {
            width: 2.5rem;
            height: 2.5rem;
            background: rgba(63, 109, 78, 0.3); /* ç»¿è‰²èƒŒæ™¯ */
            border: 1px solid rgba(139, 212, 80, 0.3);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            position: relative;
        }

        .tool-btn:hover {
            background: rgba(63, 109, 78, 0.5); /* æ·±ç»¿è‰²æ‚¬åœ */
            border-color: rgba(139, 212, 80, 0.5);
            transform: translateY(-2px);
        }

        .tool-btn.primary {
            background: linear-gradient(135deg, #3f6d4e, #8bd450); /* ç»¿è‰²æ¸å˜ */
            border-color: transparent;
        }

        .tool-btn.primary:hover {
            background: linear-gradient(135deg, #4a7d58, #9cde65);
            box-shadow: 0 4px 20px rgba(0, 200, 255, 0.4);
        }

        .tool-btn.danger {
            background: linear-gradient(135deg, #3f6d4e, #8bd450);
            border-color: transparent;
        }

        .tool-btn.danger:hover {
            background: linear-gradient(135deg, #4a7d58, #9cde65);
            box-shadow: 0 4px 20px rgba(139, 212, 80, 0.4);
        }

        /* åˆ†è¾¨ç‡è®¾ç½® */
        .resolution-settings {
            position: absolute;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: #3f6d4e; /* ç»¿è‰²èƒŒæ™¯ */
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .resolution-icon {
            font-size: 1.25rem;
            color: #999;
        }

        .resolution-input {
            width: 4.5rem;
            padding: 0.375rem 0.625rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.875rem;
            text-align: center;
            transition: all 0.3s;
        }

        .resolution-input:focus {
            outline: none;
            border-color: #3a86ff;
            background: rgba(0, 0, 0, 0.5);
        }

        /* åˆ†è¾¨ç‡é¢„è®¾ä¸‹æ‹‰ */
        .resolution-preset {
            padding: 0.375rem 0.625rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .resolution-preset:focus {
            outline: none;
            border-color: #3a86ff;
            background: rgba(0, 0, 0, 0.5);
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 1200px) {
            .keyboard-panel,
            .properties-panel {
                width: 25%;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .keyboard-panel,
            .properties-panel {
                width: 100%;
                max-width: 100%;
                height: 30vh;
            }
            
            .canvas-area {
                height: 40vh;
            }
        }

        /* æ–°å¢çš„æ‹–æ‹½é˜´å½± */
        .drag-shadow {
            position: absolute;
            width: 3rem;
            height: 3rem;
            background: rgba(63, 109, 78, 0.3); /* ç»¿è‰²å½±å­ */
            border: 2px dashed rgba(63, 109, 78, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            transform: translate(-50%, -50%);
        }

        .wheel-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        /* åˆå¹¶åçš„åˆ†è¾¨ç‡å’Œç¼©æ”¾æ§åˆ¶æ  */
        .resolution-zoom-container {
            position: absolute;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: #3f6d4e; /* ç»¿è‰²èƒŒæ™¯ */
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .zoom-icon {
            font-size: 1.25rem;
            color: #999;
        }
        
        .zoom-btn {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            padding: 0;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .zoom-slider {
            width: 120px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #3f6d4e, #8bd450); /* ç»¿è‰²æ»‘å— */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(139, 212, 80, 0.4);
            margin: 0;
        }

        .zoom-value {
            font-size: 0.875rem;
            color: #fff;
            min-width: 3rem;
            text-align: right;
        }
        
        /* æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1d1a2f, #3f6d4e);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(150, 95, 212, 0.2);
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-title {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .modal-title .icon {
            font-size: 1.5rem;
        }

        .json-output {
            background: rgba(29, 26, 47, 0.5);
            border: 1px solid rgba(139, 212, 80, 0.2);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.75rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            color: #8bd450;
        }

        .modal-buttons {
            margin-top: 1.5rem;
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.625rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(139, 212, 80, 0.3);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(139, 212, 80, 0.5);
            transform: translateY(-2px);
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #3f6d4e, #8bd450);
            border-color: transparent;
        }

        .modal-btn.primary:hover {
            background: linear-gradient(135deg, #4a7d58, #9cde65);
            box-shadow: 0 4px 20px rgba(0, 200, 255, 0.4);
        }

        /* å¯¼å…¥æ–‡ä»¶è¾“å…¥ */
        #fileInput,
        #imageInput {
            display: none;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(139, 212, 80, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 212, 80, 0.5);
        }

        /* ç©ºçŠ¶æ€ */
        .empty-state {
            color: #666;
            text-align: center;
            padding: 3rem 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .empty-state .icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        .empty-state .text {
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§é”®ç›˜é¢æ¿ -->
        <div class="keyboard-panel">
            <h2 class="panel-title">é”®ç›˜æ˜ å°„</h2>
            
            <div class="keyboard-section">
                <div class="section-title">ğŸ”¤ å­—æ¯é”®</div>
                <div class="keys-grid" id="letterKeys"></div>
            </div>
            
            <div class="keyboard-section">
                <div class="section-title">ğŸ”¢ æ•°å­—é”®</div>
                <div class="keys-grid" id="numberKeys"></div>
            </div>
            
            <div class="keyboard-section">
                <div class="section-title">ğŸ…°ï¸ åŠŸèƒ½é”®</div>
                <div class="keys-grid" id="functionKeys"></div>
            </div>
            
            <!-- æ–°å¢ç¬¦å·é”®åŒºåŸŸ -->
            <div class="keyboard-section">
                <div class="section-title">ğŸ”£ ç¬¦å·é”®</div>
                <div class="keys-grid" id="symbolKeys"></div>
            </div>
            
            <div class="keyboard-section">
                <div class="section-title">âŒ¨ï¸ ç‰¹æ®Šé”®</div>
                <div class="keys-grid" id="specialKeys"></div>
            </div>
            
            <!-- æ–°å¢æ–¹å‘é”®åŒºåŸŸ -->
            <div class="keyboard-section">
                <div class="section-title">â†•ï¸ æ–¹å‘é”®</div>
                <div class="keys-grid" id="arrowKeys"></div>
            </div>
            
            <div class="keyboard-section">
                <div class="section-title">ğŸ–±ï¸ é¼ æ ‡é”®</div>
                <div class="keys-grid" id="mouseKeys"></div>
            </div>
        </div>
        
        <!-- ä¸­é—´ç”»å¸ƒåŒºåŸŸ -->
        <div class="canvas-area">
            <div class="canvas-container" id="canvasContainer">
                <img id="backgroundImage" style="display: none;">
                <svg id="connectionSvg" style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></svg>
                <canvas id="deviceCanvas"></canvas>
            </div>
            
            <!-- å·¥å…·æ  -->
            <div class="toolbar">
                <button class="tool-btn" onclick="uploadBackgroundImage()" data-tooltip="ä¸Šä¼ èƒŒæ™¯å›¾ç‰‡">
                    <span>ğŸ–¼ï¸</span>
                </button>
                <button class="tool-btn" onclick="clearBackgroundImage()" data-tooltip="æ¸…é™¤èƒŒæ™¯">
                    <span>ğŸ—‘ï¸</span>
                </button>
                <button class="tool-btn" onclick="editMouseMove()" data-tooltip="é¼ æ ‡ç§»åŠ¨æ˜ å°„">
                    <span>ğŸ–±ï¸</span>
                </button>
                <button class="tool-btn" onclick="addSteeringWheel()" data-tooltip="æ·»åŠ æ‘‡æ†">
                    <span>ğŸ®</span>
                </button>
                <button class="tool-btn" onclick="importJSON()" data-tooltip="å¯¼å…¥é…ç½®">
                    <span>ğŸ“</span>
                </button>
                <button class="tool-btn" onclick="exportJSON()" data-tooltip="å¯¼å‡ºé…ç½®">
                    <span>ğŸ’¾</span>
                </button>
                <button class="tool-btn danger" onclick="clearAll()" data-tooltip="æ¸…ç©ºæ‰€æœ‰">
                    <span>ğŸ§¹</span>
                </button>
            </div>
            
            <!-- åˆå¹¶åçš„åˆ†è¾¨ç‡å’Œç¼©æ”¾æ§åˆ¶æ  -->
            <div class="resolution-zoom-container">
                <span class="resolution-icon">ğŸ“</span>
                <select class="resolution-preset" onchange="applyPresetResolution(this.value)">
                    <option value="">è‡ªå®šä¹‰</option>
                    <option value="640x480">480p</option>
                    <option value="1280x720">720p</option>
                    <option value="1920x1080">1080p</option>
                    <option value="2560x1440">1440p</option>
                    <option value="3840x2160">4K</option>
                </select>
                <input type="number" class="resolution-input" id="canvasWidth" value="1920">
                <span style="font-size: 0.875rem; color: #666;">Ã—</span>
                <input type="number" class="resolution-input" id="canvasHeight" value="1080">
                <button class="tool-btn" onclick="updateCanvasResolution()" data-tooltip="åº”ç”¨åˆ†è¾¨ç‡">
                    <span>âœ“</span>
                </button>
                
                <span class="zoom-icon">ğŸ”</span>
                <button class="zoom-btn" onclick="adjustZoom(-5)">âˆ’</button>
                <input type="range" class="zoom-slider" id="canvasZoom" 
                       min="25" max="150" step="5" value="100"
                       oninput="updateCanvasZoom(this.value)">
                <button class="zoom-btn" onclick="adjustZoom(5)">+</button>
                <span class="zoom-value" id="zoomValue">100%</span>
            </div>
            
            <!-- å·¥å…·æç¤º -->
            <div class="tooltip" id="tooltip"></div>
        </div>
        
        <!-- å³ä¾§å±æ€§é¢æ¿ -->
        <div class="properties-panel">
            <h2 class="panel-title no-icon">âš™ï¸ å±æ€§è®¾ç½®</h2>
            <div id="propertyEditor">
                <div class="empty-state">
                    <div class="icon">ğŸ…°ï¸</div>
                    <div class="text">é€‰æ‹©ä¸€ä¸ªæŒ‰é”®ä»¥ç¼–è¾‘å±æ€§</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ–‡ä»¶è¾“å…¥ -->
    <input type="file" id="fileInput" accept=".json">
    <input type="file" id="imageInput" accept="image/*">
    
    <!-- å¯¼å‡ºæ¨¡æ€æ¡† -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h3 class="modal-title">
                <span class="icon">ğŸ’¾</span>
                <span>å¯¼å‡ºæŒ‰é”®æ˜ å°„</span>
            </h3>
            
            <!-- æ–°å¢ä¿å­˜è·¯å¾„è®¾ç½® -->
            <div class="property-group" style="margin-bottom: 1rem;">
                <div class="property-label">
                    <span class="icon">ğŸ“</span>
                    <span>ä¿å­˜è·¯å¾„</span>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="text" class="property-input" id="savePathInput" placeholder="è¾“å…¥ä¿å­˜è·¯å¾„">
                    <button class="modal-btn" onclick="setSavePath()">è®¾ç½®</button>
                </div>
            </div>
            
            <!-- æ–°å¢è„šæœ¬åç§°è®¾ç½® -->
            <div class="property-group" style="margin-bottom: 1rem;">
                <div class="property-label">
                    <span class="icon">ğŸ“</span>
                    <span>è„šæœ¬åç§°</span>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="text" class="property-input" id="scriptNameInput" placeholder="è¾“å…¥è„šæœ¬åç§°">
                    <button class="modal-btn" onclick="setScriptName()">è®¾ç½®</button>
                </div>
            </div>
            
            <div class="json-output" id="jsonOutput"></div>
            <div class="modal-buttons">
                <button class="modal-btn" onclick="copyJSON()">
                    <span>ğŸ“‹</span>
                    <span>å¤åˆ¶</span>
                </button>
                <button class="modal-btn primary" onclick="downloadJSON()">
                    <span>â¬‡ï¸</span>
                    <span>ä¸‹è½½</span>
                </button>
                <button class="modal-btn" onclick="closeModal()">
                    <span>âœ•</span>
                    <span>å…³é—­</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- é¼ æ ‡ç§»åŠ¨æ˜ å°„æ¨¡æ€æ¡† -->
    <div class="modal" id="mouseMoveModal">
        <div class="modal-content">
            <h3 class="modal-title">
                <span class="icon">ğŸ–±ï¸</span>
                <span>é¼ æ ‡ç§»åŠ¨æ˜ å°„è®¾ç½®</span>
            </h3>
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸ“</span>
                    <span>èµ·å§‹ä½ç½® X</span>
                </div>
                <input class="property-input" type="number" step="0.001" min="0" max="1" 
                       id="mouseMoveStartX" value="0.5">
            </div>
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸ“</span>
                    <span>èµ·å§‹ä½ç½® Y</span>
                </div>
                <input class="property-input" type="number" step="0.001" min="0" max="1" 
                       id="mouseMoveStartY" value="0.5">
            </div>
            <!-- æ”¹è¿›çµæ•åº¦UI -->
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸšï¸</span>
                    <span>çµæ•åº¦è®¾ç½®</span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                    <span style="color: #999; font-size: 0.75rem; min-width: 20px;">X:</span>
                    <input type="range" class="property-input" min="0.1" max="5" step="0.1" 
                           id="mouseMoveSpeedXSlider" value="3.25" 
                           oninput="document.getElementById('mouseMoveSpeedX').value = this.value">
                    <input class="property-input" type="number" step="0.1" min="0.1" max="5" 
                           id="mouseMoveSpeedX" value="3.25" style="width: 60px;"
                           oninput="document.getElementById('mouseMoveSpeedXSlider').value = this.value">
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
                    <span style="color: #999; font-size: 0.75rem; min-width: 20px;">Y:</span>
                    <input type="range" class="property-input" min="0.1" max="5" step="0.1" 
                           id="mouseMoveSpeedYSlider" value="1.25" 
                           oninput="document.getElementById('mouseMoveSpeedY').value = this.value">
                    <input class="property-input" type="number" step="0.1" min="0.1" max="5" 
                           id="mouseMoveSpeedY" value="1.25" style="width: 60px;"
                           oninput="document.getElementById('mouseMoveSpeedYSlider').value = this.value">
                </div>
            </div>
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">â²ï¸</span>
                    <span>å®šæ—¶é‡ç½®è§†è§’</span>
                    <label class="switch">
                        <input type="checkbox" id="mouseMoveTimedReset">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <!-- æ·»åŠ è§¦å‘æŒ‰é”®è®¾ç½® -->
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸ•¹ï¸</span>
                    <span>è§¦å‘æŒ‰é”®</span>
                </div>
                <input class="property-input" type="text" id="mouseMoveKey" 
                       value="Key_QuoteLeft" placeholder="ä¾‹å¦‚: Key_QuoteLeft">
                <span style="color: #666; font-size: 0.75rem; margin-left: 0.5rem;">é»˜è®¤: ~ é”®</span>
            </div>
            <!-- å°çœ¼ç›æŒ‰é”®è®¾ç½® -->
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸ‘ï¸</span>
                    <span>å°çœ¼ç›æŒ‰é”®</span>
                </div>
                <select class="property-input" id="smallEyeKey">
                    <option value="Key_Alt">Alté”®</option>
                    <option value="ForwardButton">é¼ æ ‡å‰è¿›é”®</option>
                    <option value="BackButton">é¼ æ ‡åé€€é”®</option>
                    <option value="">ä¸ç»‘å®šï¼ˆå±å¹•ï¼‰</option>
                </select>
            </div>
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸ“</span>
                    <span>å°çœ¼ç›ä½ç½® X</span>
                </div>
                <input class="property-input" type="number" step="0.001" min="0" max="1" 
                       id="smallEyePosX" value="0.5">
            </div>
            <div class="property-group">
                <div class="property-label">
                    <span class="icon">ğŸ“</span>
                    <span>å°çœ¼ç›ä½ç½® Y</span>
                </div>
                <input class="property-input" type="number" step="0.001" min="0" max="1" 
                       id="smallEyePosY" value="0.6">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn primary" onclick="saveMouseMove()">
                    <span>âœ“</span>
                    <span>ä¿å­˜</span>
                </button>
                <button class="modal-btn" onclick="closeMouseMoveModal()">
                    <span>âœ•</span>
                    <span>å…³é—­</span>
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // å…¨å±€å˜é‡
        let canvas, ctx, canvasContainer, connectionSvg;
        let mappedKeys = [];
        let selectedKey = null;
        let isDragging = false;
        let draggedElement = null;
        let dragOffset = { x: 0, y: 0 };
        let mouseMoveMap = null;
        let switchKey = 'Key_QuoteLeft';
        let switchKeyPos = { x: 0.501, y: 0.501 };
        let canvasResolution = { width: 1920, height: 1080 };
        let dragShadow = null;
        // æ·»åŠ ä¿å­˜è·¯å¾„
        let savePath = localStorage.getItem('qtscrcpy_save_path') || '';
        // æ·»åŠ è„šæœ¬åç§°
        let scriptName = localStorage.getItem('qtscrcpy_script_name') || 'keymap.json';
        
        // é”®ç›˜å¸ƒå±€å®šä¹‰
        const keyboardLayout = {
            letters: ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', 
                     'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
                     'Z', 'X', 'C', 'V', 'B', 'N', 'M'],
            numbers: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
            functions: ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12'],
            // ç¬¦å·é”®
            symbols: [
                { key: 'QuoteLeft', icon: '`', tooltip: 'åå¼•å·' },
                { key: 'Minus', icon: '-', tooltip: 'å‡å·' },
                { key: 'Equal', icon: '=', tooltip: 'ç­‰å·' },
                { key: 'BracketLeft', icon: '[', tooltip: 'å·¦æ–¹æ‹¬å·' },
                { key: 'BracketRight', icon: ']', tooltip: 'å³æ–¹æ‹¬å·' },
                { key: 'Semicolon', icon: ';', tooltip: 'åˆ†å·' },
                { key: 'Quote', icon: "'", tooltip: 'å•å¼•å·' },
                { key: 'Comma', icon: ',', tooltip: 'é€—å·' },
                { key: 'Period', icon: '.', tooltip: 'å¥å·' },
                { key: 'Slash', icon: '/', tooltip: 'æ–œæ ' }
            ],
            // ç‰¹æ®Šé”®
            special: [
                { key: 'Space', icon: 'â£', tooltip: 'ç©ºæ ¼' },
                { key: 'Enter', icon: 'â', tooltip: 'å›è½¦' },
                { key: 'Tab', icon: 'â‡¥', tooltip: 'Tab' },
                { key: 'Shift', icon: 'â‡§', tooltip: 'Shift' },
                { key: 'Ctrl', icon: 'âŒƒ', tooltip: 'Ctrl' },
                { key: 'Alt', icon: 'âŒ¥', tooltip: 'Alt' },
                { key: 'Escape', icon: 'â‹', tooltip: 'Esc' },
                { key: 'Backspace', icon: 'âŒ«', tooltip: 'é€€æ ¼' }
            ],
            // æ–¹å‘é”®
            arrows: [
                { key: 'Up', icon: 'â†‘', tooltip: 'ä¸Šç®­å¤´' },
                { key: 'Down', icon: 'â†“', tooltip: 'ä¸‹ç®­å¤´' },
                { key: 'Left', icon: 'â†', tooltip: 'å·¦ç®­å¤´' },
                { key: 'Right', icon: 'â†’', tooltip: 'å³ç®­å¤´' }
            ],
            // é¼ æ ‡é”®ï¼ˆä¸­æ–‡æç¤ºï¼‰
            mouse: [
                { key: 'LeftButton', icon: 'ğŸ–±ï¸', tooltip: 'å·¦é”®' },
                { key: 'RightButton', icon: 'ğŸ–±ï¸', tooltip: 'å³é”®' },
                { key: 'MiddleButton', icon: 'ğŸ–±ï¸', tooltip: 'ä¸­é”®' },
                { key: 'ForwardButton', icon: 'ğŸ–±ï¸', tooltip: 'å‰è¿›é”®' },
                { key: 'BackButton', icon: 'ğŸ–±ï¸', tooltip: 'åé€€é”®' }
            ]
        };
        
        // æŒ‰é”®ç±»å‹
        const keyTypes = {
            KMT_CLICK: 'å•å‡»',
            KMT_CLICK_TWICE: 'åŒå‡»',
            KMT_STEER_WHEEL: 'æ‘‡æ†',
            KMT_SMALL_EYE: 'è‡ªç”±è§†è§’'
        };
        
        // åˆå§‹åŒ–
        function init() {
            canvas = document.getElementById('deviceCanvas');
            ctx = canvas.getContext('2d');
            canvasContainer = document.getElementById('canvasContainer');
            connectionSvg = document.getElementById('connectionSvg');
            
            // è®¾ç½®ç”»å¸ƒå¤§å°
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // åˆå§‹åŒ–é”®ç›˜
            initKeyboard();
            
            // åˆå§‹åŒ–ç”»å¸ƒäº‹ä»¶
            initCanvasEvents();
            
            // åˆå§‹åŒ–å·¥å…·æç¤º
            initTooltips();
            
            // æ–‡ä»¶è¾“å…¥äº‹ä»¶
            document.getElementById('fileInput').addEventListener('change', handleFileImport);
            document.getElementById('imageInput').addEventListener('change', handleImageUpload);
            
            // å…¨å±€é¼ æ ‡äº‹ä»¶
            document.addEventListener('mousemove', throttledMouseMove);
            document.addEventListener('mouseup', handleGlobalMouseUp);
            
            // æ·»åŠ å¿«æ·é”®
            document.addEventListener('keydown', handleKeyDown);
            
            // å°è¯•æ¢å¤è‡ªåŠ¨ä¿å­˜
            restoreAutoSave();
            
            // è®¾ç½®è‡ªåŠ¨ä¿å­˜
            window.autoSaveTimer = setInterval(autoSave, 30000);
            
            // ç»˜åˆ¶åˆå§‹ç½‘æ ¼
            drawCanvas();
        }
        
        // æ·»åŠ èŠ‚æµå‡½æ•°
        function throttle(func, delay) {
            let lastCall = 0;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    func.apply(this, args);
                }
            };
        }
        
        // åˆ›å»ºæ‹–æ‹½é˜´å½±
        function createDragShadow(x, y, scale = 1) {
            const shadow = document.createElement('div');
            shadow.className = 'drag-shadow';
            shadow.style.left = x + 'px';
            shadow.style.top = y + 'px';
            shadow.style.transform = `translate(-50%, -50%) scale(${scale})`;
            canvasContainer.appendChild(shadow);
            return shadow;
        }
        
        // å¤„ç†é”®ç›˜äº‹ä»¶
        function handleKeyDown(e) {
            // Ctrl+S ä¿å­˜
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                exportJSON();
            }
            
            // Ctrl+O æ‰“å¼€
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                importJSON();
            }
            
            // Delete åˆ é™¤é€‰ä¸­çš„é”®
            if (e.key === 'Delete' && selectedKey) {
                deleteKey(selectedKey.id);
            }
            
            // Esc å–æ¶ˆé€‰æ‹©
            if (e.key === 'Escape') {
                selectKey(null);
            }
        }
        
        // è‡ªåŠ¨ä¿å­˜åˆ°localStorage
        function autoSave() {
            try {
                const data = {
                    keyMapNodes: mappedKeys.map(key => ({...key})),
                    mouseMoveMap: mouseMoveMap,
                    switchKey: switchKey,
                    switchKeyPos: switchKeyPos,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('qtscrcpy_keymap_autosave', JSON.stringify(data));
            } catch (e) {
                console.warn('è‡ªåŠ¨ä¿å­˜å¤±è´¥:', e);
            }
        }
        
        // æ·»åŠ æ¢å¤åŠŸèƒ½
        function restoreAutoSave() {
            try {
                const saved = localStorage.getItem('qtscrcpy_keymap_autosave');
                if (saved) {
                    const data = JSON.parse(saved);
                    const timeDiff = Date.now() - data.timestamp;
                    
                    // å¦‚æœæ˜¯24å°æ—¶å†…çš„æ•°æ®
                    if (timeDiff < 24 * 60 * 60 * 1000) {
                        if (confirm('æ£€æµ‹åˆ°æœªä¿å­˜çš„æ•°æ®ï¼Œæ˜¯å¦æ¢å¤ï¼Ÿ')) {
                            loadMapping(data);
                        }
                    }
                }
            } catch (e) {
                console.warn('æ¢å¤è‡ªåŠ¨ä¿å­˜å¤±è´¥:', e);
            }
        }
        
        // æ¸…ç†å‡½æ•°
        function cleanup() {
            // ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
            document.removeEventListener('mousemove', throttledMouseMove);
            document.removeEventListener('mouseup', handleGlobalMouseUp);
            document.removeEventListener('keydown', handleKeyDown);
            
            // æ¸…ç†å®šæ—¶å™¨
            if (window.autoSaveTimer) {
                clearInterval(window.autoSaveTimer);
            }
            
            // æ¸…ç†DOMå¼•ç”¨
            mappedKeys = [];
            selectedKey = null;
            draggedElement = null;
        }
        
        // åœ¨é¡µé¢å¸è½½æ—¶è°ƒç”¨
        window.addEventListener('beforeunload', cleanup);
        
        // èŠ‚æµåçš„é¼ æ ‡ç§»åŠ¨å¤„ç†
        const throttledMouseMove = throttle(function(e) {
            if (!isDragging || !selectedKey || !draggedElement) return;
            
            const containerRect = canvasContainer.getBoundingClientRect();
            
            // ç›´æ¥ä½¿ç”¨é¼ æ ‡ç›¸å¯¹äºå®¹å™¨çš„ä½ç½®
            let x = (e.clientX - containerRect.left) / containerRect.width;
            let y = (e.clientY - containerRect.top) / containerRect.height;
            
            // é™åˆ¶åœ¨ç”»å¸ƒèŒƒå›´å†…
            x = Math.max(0, Math.min(1, x));
            y = Math.max(0, Math.min(1, y));
            
            // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨æ˜ å°„é”®ä¸Š
            const dragType = draggedElement.dataset.dragType;
            const keyType = draggedElement.dataset.keyType;
            
            if (selectedKey.type === 'KMT_SMALL_EYE' || selectedKey.type === 'KMT_STEER_WHEEL') {
                selectedKey.centerPos.x = x;
                selectedKey.centerPos.y = y;
            } else {
                selectedKey.pos.x = x;
                selectedKey.pos.y = y;
                selectedKey.pressPos.x = x;
                selectedKey.pressPos.y = y;
                selectedKey.releasePos.x = x;
                selectedKey.releasePos.y = y;
            }
            
            // æ›´æ–°å…ƒç´ ä½ç½®
            updateMappedKeyPositions(selectedKey);
            
            // æ›´æ–°è¿æ¥çº¿
            updateConnectionLines();
            
            // å®æ—¶æ›´æ–°å±æ€§é¢æ¿ä¸­çš„åæ ‡å€¼
            updateCoordinateInputs();
            
            // æ›´æ–°æ‹–æ‹½é˜´å½±ä½ç½®
            if (dragShadow) {
                dragShadow.style.left = (e.clientX - containerRect.left) + 'px';
                dragShadow.style.top = (e.clientY - containerRect.top) + 'px';
            }
        }, 16); // çº¦60fps
        
        // é˜²æŠ–å‡½æ•°
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // åˆå§‹åŒ–å·¥å…·æç¤º
        function initTooltips() {
            const tooltip = document.getElementById('tooltip');
            let currentTarget = null;
            let hideTimeout = null;
            let observer = null;
            
            // æ›´æ–°tooltipä½ç½®çš„å‡½æ•°
            const updateTooltipPosition = (target) => {
                if (!target || !tooltip.classList.contains('show')) return;
                
                const rect = target.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                
                let left = rect.left + rect.width / 2;
                let top = rect.bottom + 8;
                
                // ç¡®ä¿ä¸è¶…å‡ºè§†å£
                if (left - tooltipRect.width / 2 < 0) {
                    left = tooltipRect.width / 2;
                }
                if (left + tooltipRect.width / 2 > window.innerWidth) {
                    left = window.innerWidth - tooltipRect.width / 2;
                }
                if (top + tooltipRect.height > window.innerHeight) {
                    top = rect.top - tooltipRect.height - 8;
                    tooltip.classList.add('bottom');
                } else {
                    tooltip.classList.remove('bottom');
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
                tooltip.style.transform = 'translateX(-50%)';
            };
            
            // é˜²æŠ–çš„ä½ç½®æ›´æ–°å‡½æ•°
            const debouncedUpdatePosition = debounce(updateTooltipPosition, 50);
            
            // æ˜¾ç¤ºtooltip
            const showTooltip = (target) => {
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
                
                currentTarget = target;
                const text = target.getAttribute('data-tooltip');
                tooltip.textContent = text;
                tooltip.classList.add('show');
                
                // ç«‹å³æ›´æ–°ä½ç½®
                updateTooltipPosition(target);
                
                // ä½¿ç”¨Intersection Observerç›‘å¬å…ƒç´ ä½ç½®å˜åŒ–
                if (observer) observer.disconnect();
                observer = new IntersectionObserver(() => {
                    debouncedUpdatePosition(target);
                }, { threshold: [0, 1] });
                observer.observe(target);
            };
            
            // éšè—tooltip
            const hideTooltip = () => {
                hideTimeout = setTimeout(() => {
                    tooltip.classList.remove('show');
                    currentTarget = null;
                    if (observer) {
                        observer.disconnect();
                        observer = null;
                    }
                }, 100);
            };
            
            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜
            document.addEventListener('mouseenter', (e) => {
                if (e.target.hasAttribute('data-tooltip')) {
                    showTooltip(e.target);
                }
            }, true);
            
            document.addEventListener('mouseleave', (e) => {
                if (e.target.hasAttribute('data-tooltip')) {
                    hideTooltip();
                }
            }, true);
            
            // ç›‘å¬æ»šåŠ¨å’Œçª—å£å¤§å°å˜åŒ–
            window.addEventListener('scroll', () => {
                if (currentTarget) {
                    debouncedUpdatePosition(currentTarget);
                }
            }, true);
            
            window.addEventListener('resize', () => {
                if (currentTarget) {
                    debouncedUpdatePosition(currentTarget);
                }
            });
        }
        
        // è°ƒæ•´ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            const container = document.querySelector('.canvas-area');
            const maxWidth = container.clientWidth * 0.8;
            const maxHeight = container.clientHeight * 0.8;
            
            // æ ¹æ®è®¾å®šçš„åˆ†è¾¨ç‡è®¡ç®—å®½é«˜æ¯”
            const aspectRatio = canvasResolution.width / canvasResolution.height;
            
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            // è®¾ç½®å®¹å™¨å¤§å°
            canvasContainer.style.width = width + 'px';
            canvasContainer.style.height = height + 'px';
            
            // è®¾ç½®ç”»å¸ƒå®é™…åƒç´ å¤§å°
            canvas.width = canvasResolution.width;
            canvas.height = canvasResolution.height;
            
            // æ›´æ–°æ‰€æœ‰æ˜ å°„é”®çš„ä½ç½®
            mappedKeys.forEach(keyData => {
                updateMappedKeyPositions(keyData);
            });
            
            // æ›´æ–°è¿æ¥çº¿
            updateConnectionLines();
            
            // é‡ç»˜
            drawCanvas();
        }
        
        // æ›´æ–°ç”»å¸ƒåˆ†è¾¨ç‡
        function updateCanvasResolution() {
            const width = parseInt(document.getElementById('canvasWidth').value) || 1920;
            const height = parseInt(document.getElementById('canvasHeight').value) || 1080;
            
            canvasResolution.width = width;
            canvasResolution.height = height;
            
            resizeCanvas();
        }
        
        // ä¸Šä¼ èƒŒæ™¯å›¾ç‰‡
        function uploadBackgroundImage() {
            document.getElementById('imageInput').click();
        }
        
        // å¤„ç†å›¾ç‰‡ä¸Šä¼ 
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    // æ˜¾ç¤ºå›¾ç‰‡
                    const bgImg = document.getElementById('backgroundImage');
                    bgImg.src = event.target.result;
                    bgImg.style.display = 'block';
                    
                    // è‡ªåŠ¨è°ƒæ•´ç”»å¸ƒåˆ†è¾¨ç‡
                    if (confirm(`æ£€æµ‹åˆ°å›¾ç‰‡åˆ†è¾¨ç‡ä¸º ${img.width}x${img.height}ï¼Œæ˜¯å¦è°ƒæ•´ç”»å¸ƒåˆ†è¾¨ç‡ï¼Ÿ`)) {
                        document.getElementById('canvasWidth').value = img.width;
                        document.getElementById('canvasHeight').value = img.height;
                        updateCanvasResolution();
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            
            e.target.value = '';
        }
        
        // æ¸…é™¤èƒŒæ™¯å›¾ç‰‡
        function clearBackgroundImage() {
            const img = document.getElementById('backgroundImage');
            img.style.display = 'none';
            img.src = '';
        }
        
        // åˆå§‹åŒ–é”®ç›˜
        function initKeyboard() {
            // å­—æ¯é”®
            const letterContainer = document.getElementById('letterKeys');
            keyboardLayout.letters.forEach(letter => {
                const key = createKeyElement(`Key_${letter}`, letter);
                letterContainer.appendChild(key);
            });
            
            // æ•°å­—é”®
            const numberContainer = document.getElementById('numberKeys');
            keyboardLayout.numbers.forEach(number => {
                const key = createKeyElement(`Key_${number}`, number);
                numberContainer.appendChild(key);
            });
            
            // åŠŸèƒ½é”®
            const functionContainer = document.getElementById('functionKeys');
            keyboardLayout.functions.forEach(fn => {
                const key = createKeyElement(`Key_${fn}`, fn, 'function');
                functionContainer.appendChild(key);
            });
            
            // ç¬¦å·é”®
            const symbolContainer = document.getElementById('symbolKeys');
            keyboardLayout.symbols.forEach(symbol => {
                const key = createKeyElement(`Key_${symbol.key}`, symbol.icon, 'symbol');
                key.setAttribute('data-tooltip', symbol.tooltip);
                symbolContainer.appendChild(key);
            });
            
            // ç‰¹æ®Šé”®
            const specialContainer = document.getElementById('specialKeys');
            keyboardLayout.special.forEach(sp => {
                const key = createKeyElement(`Key_${sp.key}`, sp.icon, 'special');
                key.setAttribute('data-tooltip', sp.tooltip);
                specialContainer.appendChild(key);
            });
            
            // æ–¹å‘é”®
            const arrowContainer = document.getElementById('arrowKeys');
            keyboardLayout.arrows.forEach(arrow => {
                const key = createKeyElement(`Key_${arrow.key}`, arrow.icon, 'special');
                key.setAttribute('data-tooltip', arrow.tooltip);
                arrowContainer.appendChild(key);
            });
            
            // é¼ æ ‡é”®ï¼ˆä¸­æ–‡æç¤ºï¼‰
            const mouseContainer = document.getElementById('mouseKeys');
            keyboardLayout.mouse.forEach(mouse => {
                const key = createKeyElement(mouse.key, mouse.icon, 'special');
                key.setAttribute('data-tooltip', mouse.tooltip);
                mouseContainer.appendChild(key);
            });
            
            // é‡æ–°åˆå§‹åŒ–å·¥å…·æç¤º
            initTooltips();
        }
        
        // åˆ›å»ºé”®å…ƒç´ 
        function createKeyElement(keyCode, label, className = '') {
            const key = document.createElement('div');
            key.className = `key ${className}`;
            key.textContent = label;
            key.dataset.keyCode = keyCode;
            key.draggable = true;
            
            // æ‹–æ‹½äº‹ä»¶
            key.addEventListener('dragstart', handleDragStart);
            key.addEventListener('dragend', handleDragEnd);
            
            return key;
        }
        
        // å¤„ç†æ‹–æ‹½å¼€å§‹
        function handleDragStart(e) {
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('keyCode', e.target.dataset.keyCode);
            e.dataTransfer.setData('label', e.target.textContent);
            e.target.classList.add('dragging');
        }
        
        // å¤„ç†æ‹–æ‹½ç»“æŸ
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        // åˆå§‹åŒ–ç”»å¸ƒäº‹ä»¶
        function initCanvasEvents() {
            canvasContainer.addEventListener('dragover', handleCanvasDragOver);
            canvasContainer.addEventListener('drop', handleCanvasDrop);
            canvasContainer.addEventListener('mousemove', handleCanvasMouseMove);
            canvasContainer.addEventListener('click', handleCanvasClick);
        }
        
        // å¤„ç†ç”»å¸ƒæ‹–æ‹½æ‚¬åœ
        function handleCanvasDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
        
        // å¤„ç†ç”»å¸ƒæ”¾ç½®
        function handleCanvasDrop(e) {
            e.preventDefault();
            
            const keyCode = e.dataTransfer.getData('keyCode');
            const label = e.dataTransfer.getData('label');
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            if (keyCode) {
                // åˆ›å»ºæ˜ å°„é”®
                createMappedKey(keyCode, label, x, y);
            }
        }
        
        // å¤„ç†ç”»å¸ƒé¼ æ ‡ç§»åŠ¨
        function handleCanvasMouseMove(e) {
            if (e.dataTransfer || isDragging) return;
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨æ˜ å°„é”®ä¸Š
            const hoveredKey = getMappedKeyAt(x, y);
            canvasContainer.style.cursor = hoveredKey ? 'move' : 'default';
        }
        
        // å¤„ç†ç”»å¸ƒç‚¹å‡»
        function handleCanvasClick(e) {
            const rect = canvasContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ˜ å°„é”®
            const clickedKey = getMappedKeyAt(x, y);
            selectKey(clickedKey);
        }
        
        // åˆ›å»ºæ˜ å°„é”®
        function createMappedKey(keyCode, label, x, y, type = 'KMT_CLICK', config = {}) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒæŒ‰é”®ï¼ˆæ‘‡æ†ç±»å‹é™¤å¤–ï¼‰
            if (type !== 'KMT_STEER_WHEEL' && keyCode) {
                const existingKey = mappedKeys.find(k => k.key === keyCode);
                if (existingKey) {
                    alert(`æŒ‰é”® ${keyCode} å·²ç»å­˜åœ¨äºç”»å¸ƒä¸Šï¼Œè¯·é€‰æ‹©å…¶ä»–æŒ‰é”®æˆ–åˆ é™¤ç°æœ‰æ˜ å°„`);
                    return null;
                }
            }
            
            const keyData = {
                id: Date.now() + Math.random(),
                key: keyCode,
                label: label,
                type: type,
                pos: { x, y },
                pressPos: { x, y },
                releasePos: { x, y },
                scale: 1,
                resetMove: false,
                switchMap: false,
                showMouse: false,
                resetView: false,
                ...config
            };
            
            // å¦‚æœæ˜¯æ‘‡æ†ç±»å‹ï¼Œç¡®ä¿è®¾ç½®centerPos
            if (type === 'KMT_STEER_WHEEL' && !keyData.centerPos) {
                keyData.centerPos = { x, y };
                // è®¾ç½®é»˜è®¤åç§»å€¼
                keyData.leftOffset = keyData.leftOffset || 0.1;
                keyData.rightOffset = keyData.rightOffset || 0.1;
                keyData.upOffset = keyData.upOffset || 0.27;
                keyData.downOffset = keyData.downOffset || 0.2;
            }
            
            mappedKeys.push(keyData);
            
            // åˆ›å»ºä¸»æŒ‰é”®å…ƒç´ 
            const pressElement = createMappedKeyElement(keyData, 'press');
            canvasContainer.appendChild(pressElement);
            
            // æ›´æ–°ä½ç½®
            updateMappedKeyPositions(keyData);
            
            // é€‰ä¸­æ–°åˆ›å»ºçš„é”®
            selectKey(keyData);
            
            return keyData;
        }
        
        // åˆ›å»ºè‡ªç”±è§†è§’æŒ‰é”®
        function createSmallEye(keyCode, centerX, centerY) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒæŒ‰é”®
            const existingKey = mappedKeys.find(k => k.key === keyCode);
            if (existingKey) {
                alert(`æŒ‰é”® ${keyCode} å·²ç»å­˜åœ¨äºç”»å¸ƒä¸Šï¼Œè¯·é€‰æ‹©å…¶ä»–æŒ‰é”®æˆ–åˆ é™¤ç°æœ‰æ˜ å°„`);
                return null;
            }
            
            const keyData = {
                id: Date.now() + Math.random(),
                key: keyCode,
                label: 'è‡ªç”±è§†è§’',
                type: 'KMT_SMALL_EYE',
                centerPos: { x: centerX, y: centerY },
                radius: 0.15,
                sensitivity: 1.0
            };
            
            mappedKeys.push(keyData);
            
            // åˆ›å»ºæ–½æ³•åŒºåŸŸ
            const castArea = createMappedKeyElement(keyData);
            canvasContainer.appendChild(castArea);
            
            selectKey(keyData);
            return keyData;
        }
        
        // åˆ›å»ºæ˜ å°„é”®å…ƒç´ 
        function createMappedKeyElement(keyData, type = 'press') {
            const element = document.createElement('div');
            element.className = 'mapped-key';
            
            if (type === 'press') {
                element.classList.add('press-key');
                element.dataset.keyId = keyData.id;
                element.dataset.keyType = 'press';
            } else {
                element.classList.add('release-key');
                element.dataset.keyId = keyData.id;
                element.dataset.keyType = 'release';
            }
            
            if (keyData.type === 'KMT_SMALL_EYE') {
                element.classList.add('directional-cast');
            }
            
            // è·å–å›¾æ ‡ - ä½¿ç”¨ä¸­æ–‡æ ‡ç­¾
            let icon = keyData.label;
            const chineseLabels = {
                'Key_Space': 'ç©ºæ ¼',
                'Key_Enter': 'å›è½¦',
                'Key_Tab': 'Tab',
                'Key_Shift': 'Shift',
                'Key_Ctrl': 'Ctrl',
                'Key_Alt': 'Alt',
                'Key_Escape': 'Esc',
                'Key_Backspace': 'é€€æ ¼',
                'LeftButton': 'å·¦é”®',
                'RightButton': 'å³é”®',
                'MiddleButton': 'ä¸­é”®',
                'ForwardButton': 'å‰è¿›',
                'BackButton': 'åé€€'
            };
            
            if (chineseLabels[keyData.key]) {
                icon = chineseLabels[keyData.key];
            } else if (keyData.type === 'KMT_STEER_WHEEL') {
                icon = 'æ‘‡æ†';
            } else if (keyData.type === 'KMT_SMALL_EYE') {
                icon = 'è‡ªç”±è§†è§’';
            }
            
            if (keyData.type === 'KMT_STEER_WHEEL') {
                element.classList.add('wheel');
                element.style.width = '16rem';
                element.style.height = '16rem';
                element.style.background = 'transparent !important';
                element.style.border = 'none !important';
                element.style.boxShadow = 'none !important';
                
                // ç§»é™¤æ‘‡æ†æ–‡å­—æ˜¾ç¤º
                element.innerHTML = `
                    <canvas class="wheel-canvas"></canvas>
                    <div class="delete-btn" onclick="deleteKey('${keyData.id}')">Ã—</div>
                `;
                
                // å»¶è¿Ÿç»˜åˆ¶å…«è¾¹å½¢
                setTimeout(() => drawOctagonWheel(keyData), 0);
            } else {
                element.innerHTML = `
                    <div class="key-icon">${icon}</div>
                    <div class="delete-btn" onclick="deleteKey('${keyData.id}')">Ã—</div>
                `;
            }
            
            // åº”ç”¨ç¼©æ”¾
            if (keyData.scale && keyData.scale !== 1) {
                element.style.transform = `translate(-50%, -50%) scale(${keyData.scale})`;
            }
            
            // è®¾ç½®å·¥å…·æç¤º
            element.setAttribute('data-tooltip', `${keyData.key} - ${keyTypes[keyData.type] || keyData.type}`);
            
            // æ‹–æ‹½äº‹ä»¶
            element.addEventListener('mousedown', handleMappedKeyMouseDown);
            
            return element;
        }
        
        // ç»˜åˆ¶å…«è¾¹å½¢æ‘‡æ†
        function drawOctagonWheel(keyData) {
            const element = document.querySelector(`[data-key-id="${keyData.id}"]`);
            if (!element) return;
            
            // åˆ›å»ºæˆ–è·å–canvas
            let canvas = element.querySelector('.wheel-canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.className = 'wheel-canvas';
                canvas.width = 100;
                canvas.height = 100;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                element.appendChild(canvas);
            }
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è·å–åç§»å€¼
            const upOffset = keyData.upOffset || 0.27;
            const downOffset = keyData.downOffset || 0.2;
            const leftOffset = keyData.leftOffset || 0.1;
            const rightOffset = keyData.rightOffset || 0.1;
            
            // è®¡ç®—å…«ä¸ªæ–¹å‘çš„ç‚¹ï¼ˆåŸºäºåç§»å€¼ï¼‰
            const baseRadius = 40; // åŸºç¡€åŠå¾„
            const points = [
                // ä¸Š
                { x: centerX, y: centerY - baseRadius * upOffset / 0.27 },
                // å³ä¸Š
                { x: centerX + baseRadius * rightOffset / 0.1 * 0.707, y: centerY - baseRadius * upOffset / 0.27 * 0.707 },
                // å³
                { x: centerX + baseRadius * rightOffset / 0.1, y: centerY },
                // å³ä¸‹
                { x: centerX + baseRadius * rightOffset / 0.1 * 0.707, y: centerY + baseRadius * downOffset / 0.2 * 0.707 },
                // ä¸‹
                { x: centerX, y: centerY + baseRadius * downOffset / 0.2 },
                // å·¦ä¸‹
                { x: centerX - baseRadius * leftOffset / 0.1 * 0.707, y: centerY + baseRadius * downOffset / 0.2 * 0.707 },
                // å·¦
                { x: centerX - baseRadius * leftOffset / 0.1, y: centerY },
                // å·¦ä¸Š
                { x: centerX - baseRadius * leftOffset / 0.1 * 0.707, y: centerY - baseRadius * upOffset / 0.27 * 0.707 }
            ];
            
            // ç»˜åˆ¶å…«è¾¹å½¢
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            
            // å¡«å……å’Œæè¾¹
            ctx.fillStyle = 'rgba(150, 95, 212, 0.2)';
            ctx.fill();
            ctx.strokeStyle = '#965fd4';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç»˜åˆ¶ä¸­å¿ƒç‚¹
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#965fd4';
            ctx.fill();
            
            // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤º
            ctx.font = '10px Arial';
            ctx.fillStyle = '#8bd450';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ ‡è®°å…«ä¸ªæ–¹å‘
            const directions = ['â†‘', 'â†—', 'â†’', 'â†˜', 'â†“', 'â†™', 'â†', 'â†–'];
            points.forEach((point, i) => {
                ctx.fillText(directions[i], 
                    centerX + (point.x - centerX) * 1.2, 
                    centerY + (point.y - centerY) * 1.2
                );
            });
        }
        
        // å¤„ç†æ˜ å°„é”®é¼ æ ‡æŒ‰ä¸‹
        function handleMappedKeyMouseDown(e) {
            if (e.target.classList.contains('delete-btn')) return;
            
            e.preventDefault();
            
            const keyId = e.currentTarget.dataset.keyId;
            const keyData = mappedKeys.find(k => k.id == keyId);
            
            if (keyData) {
                isDragging = true;
                draggedElement = e.currentTarget;
                
                selectKey(keyData);
                
                const containerRect = canvasContainer.getBoundingClientRect();
                
                // åˆ›å»ºæ‹–æ‹½é˜´å½±
                dragShadow = createDragShadow(
                    e.clientX - containerRect.left,
                    e.clientY - containerRect.top,
                    keyData.scale || 1
                );
                
                dragOffset.x = 0;
                dragOffset.y = 0;
            }
        }
        
        // å…¨å±€é¼ æ ‡é‡Šæ”¾
        function handleGlobalMouseUp() {
            if (isDragging) {
                isDragging = false;
                draggedElement = null;
                
                // ç§»é™¤æ‹–æ‹½é˜´å½±
                if (dragShadow) {
                    dragShadow.remove();
                    dragShadow = null;
                }
            }
        }
        
        // æ›´æ–°æ˜ å°„é”®ä½ç½®
        function updateMappedKeyPositions(keyData) {
            // æ›´æ–°æŒ‰ä¸‹ä½ç½®çš„å…ƒç´ 
            const pressElement = document.querySelector(`[data-key-id="${keyData.id}"][data-key-type="press"]`);
            if (pressElement) {
                if (keyData.type === 'KMT_SMALL_EYE') {
                    pressElement.style.left = (keyData.centerPos.x * 100) + '%';
                    pressElement.style.top = (keyData.centerPos.y * 100) + '%';
                } else if (keyData.type === 'KMT_STEER_WHEEL') {
                    // æ‘‡æ†ç±»å‹ä¹Ÿä½¿ç”¨ centerPos
                    pressElement.style.left = (keyData.centerPos.x * 100) + '%';
                    pressElement.style.top = (keyData.centerPos.y * 100) + '%';
                } else {
                    const x = keyData.pos.x * 100;
                    const y = keyData.pos.y * 100;
                    pressElement.style.left = x + '%';
                    pressElement.style.top = y + '%';
                }
                
                if (keyData.scale && keyData.scale !== 1) {
                    pressElement.style.transform = `translate(-50%, -50%) scale(${keyData.scale})`;
                }
            }
            
            // æ›´æ–°è¿æ¥çº¿
            updateConnectionLines();
        }
        
        // æ›´æ–°è¿æ¥çº¿
        function updateConnectionLines() {
            connectionSvg.innerHTML = '';
        }
        
        // è·å–æŒ‡å®šä½ç½®çš„æ˜ å°„é”®
        function getMappedKeyAt(x, y) {
            const elements = document.querySelectorAll('.mapped-key');
            
            for (let element of elements) {
                const rect = element.getBoundingClientRect();
                const containerRect = canvasContainer.getBoundingClientRect();
                
                const relativeRect = {
                    left: rect.left - containerRect.left,
                    right: rect.right - containerRect.left,
                    top: rect.top - containerRect.top,
                    bottom: rect.bottom - containerRect.top
                };
                
                if (x >= relativeRect.left && 
                    x <= relativeRect.right &&
                    y >= relativeRect.top && 
                    y <= relativeRect.bottom) {
                    const keyId = element.dataset.keyId;
                    return mappedKeys.find(k => k.id == keyId);
                }
            }
            
            return null;
        }
        
        // é€‰ä¸­é”®
        function selectKey(keyData) {
            // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.mapped-key').forEach(el => {
                el.classList.remove('selected');
            });
            
            selectedKey = keyData;
            
            if (keyData) {
                // é€‰ä¸­æ‰€æœ‰ç›¸å…³å…ƒç´ 
                document.querySelectorAll(`[data-key-id="${keyData.id}"]`).forEach(el => {
                    el.classList.add('selected');
                });
                
                // æ›´æ–°å±æ€§ç¼–è¾‘å™¨
                updatePropertyEditor();
            } else {
                // æ¸…ç©ºå±æ€§ç¼–è¾‘å™¨
                clearPropertyEditor();
            }
        }
        
        // æ›´æ–°å±æ€§ç¼–è¾‘å™¨
        function updatePropertyEditor() {
            if (!selectedKey) {
                clearPropertyEditor();
                return;
            }
            
            const editor = document.getElementById('propertyEditor');
            
            let html = '';
            
            // æ‘‡æ†ç±»å‹ä¸æ˜¾ç¤ºæŒ‰é”®è¾“å…¥æ¡†
            if (selectedKey.type !== 'KMT_STEER_WHEEL') {
                html += `
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ•¹ï¸</span>
                            <span>æŒ‰é”®</span>
                        </div>
                        <input class="property-input" value="${selectedKey.key}" onchange="updateKeyProp('key', this.value)">
                    </div>
                `;
            }
            
            html += `
                <div class="property-group">
                    <div class="property-label">
                        <span class="icon">ğŸ·ï¸</span>
                        <span>æ ‡ç­¾</span>
                    </div>
                    <input class="property-input" value="${selectedKey.label}" onchange="updateKeyLabel(this.value)">
                </div>
                
                <div class="property-group">
                    <div class="property-label">
                        <span class="icon">ğŸšï¸</span>
                        <span>ç±»å‹</span>
                    </div>
                    <select class="property-input" onchange="updateKeyType(this.value)">
                        ${Object.entries(keyTypes).map(([value, label]) => 
                            `<option value="${value}" ${selectedKey.type === value ? 'selected' : ''}>${label}</option>`
                        ).join('')}
                    </select>
                </div>
            `;
            
            // è‡ªç”±è§†è§’çš„å±æ€§
            if (selectedKey.type === 'KMT_SMALL_EYE') {
                html += `
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>æŒ‰é”®å¤§å°</span>
                        </div>
                        <input class="property-input" type="range" min="0.5" max="2" step="0.1" 
                               value="${selectedKey.scale || 1}" 
                               oninput="updateKeyScale(this.value)">
                        <span style="color: #999; font-size: 0.75rem; margin-left: 0.5rem;">${((selectedKey.scale || 1) * 100).toFixed(0)}%</span>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>ä¸­å¿ƒä½ç½® X</span>
                        </div>
                        <input class="property-input" type="number" step="0.001" min="0" max="1" 
                               value="${selectedKey.centerPos.x.toFixed(3)}" 
                               onchange="updateKeyPos('x', this.value, 'center')">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>ä¸­å¿ƒä½ç½® Y</span>
                        </div>
                        <input class="property-input" type="number" step="0.001" min="0" max="1" 
                               value="${selectedKey.centerPos.y.toFixed(3)}" 
                               onchange="updateKeyPos('y', this.value, 'center')">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>è§‚å¯ŸèŒƒå›´</span>
                        </div>
                        <input class="property-input" type="number" step="0.01" min="0.05" max="0.5" 
                               value="${selectedKey.radius || 0.15}" 
                               onchange="updateKeyProp('radius', parseFloat(this.value))">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸšï¸</span>
                            <span>çµæ•åº¦</span>
                        </div>
                        <input class="property-input" type="range" min="0.1" max="5" step="0.1" 
                               value="${selectedKey.sensitivity || 1}" 
                               oninput="updateKeyProp('sensitivity', parseFloat(this.value))">
                    </div>
                `;
            } 
            // å…¶ä»–ç±»å‹çš„å±æ€§
            else if (selectedKey.type !== 'KMT_STEER_WHEEL') {
                html += `
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>æŒ‰é”®å¤§å°</span>
                        </div>
                        <input class="property-input" type="range" min="0.5" max="2" step="0.1" 
                               value="${selectedKey.scale || 1}" 
                               oninput="updateKeyScale(this.value)">
                        <span style="color: #999; font-size: 0.75rem; margin-left: 0.5rem;">${((selectedKey.scale || 1) * 100).toFixed(0)}%</span>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>ä½ç½® X</span>
                        </div>
                        <input class="property-input" type="number" step="0.001" min="0" max="1" 
                               value="${selectedKey.pos.x.toFixed(3)}" 
                               onchange="updateKeyPos('x', this.value, 'main')">
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ“</span>
                            <span>ä½ç½® Y</span>
                        </div>
                        <input class="property-input" type="number" step="0.001" min="0" max="1" 
                               value="${selectedKey.pos.y.toFixed(3)}" 
                               onchange="updateKeyPos('y', this.value, 'main')">
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ–±ï¸</span>
                            <span>æ˜¾ç¤ºé¼ æ ‡</span>
                            <label class="switch">
                                <input type="checkbox" ${selectedKey.showMouse ? 'checked' : ''} 
                                       onchange="updateKeyProp('showMouse', this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ‘ï¸</span>
                            <span>é‡ç½®è§†è§’</span>
                            <label class="switch">
                                <input type="checkbox" ${selectedKey.resetView ? 'checked' : ''} 
                                       onchange="updateKeyProp('resetView', this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â²ï¸</span>
                            <span>é‡ç½®ç§»åŠ¨</span>
                            <label class="switch">
                                <input type="checkbox" ${selectedKey.resetMove ? 'checked' : ''} 
                                       onchange="updateKeyProp('resetMove', this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ”„</span>
                            <span>åˆ‡æ¢æ˜ å°„</span>
                            <label class="switch">
                                <input type="checkbox" ${selectedKey.switchMap ? 'checked' : ''} 
                                       onchange="updateKeyProp('switchMap', this.checked)">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                `;
            }
            
            // æ‘‡æ†ç±»å‹çš„å±æ€§
            if (selectedKey.type === 'KMT_STEER_WHEEL') {
                html += `
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ”¼</span>
                            <span>å‘ä¸Šé”®</span>
                        </div>
                        <input class="property-input" value="${selectedKey.upKey || 'Key_W'}" 
                               onchange="updateKeyProp('upKey', this.value)">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â†•ï¸</span>
                            <span>å‘ä¸Šåç§»</span>
                        </div>
                        <input class="property-input" type="number" step="0.01" min="0" max="1" 
                               value="${selectedKey.upOffset || 0.27}" 
                               onchange="updateKeyProp('upOffset', parseFloat(this.value))">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">ğŸ”½</span>
                            <span>å‘ä¸‹é”®</span>
                        </div>
                        <input class="property-input" value="${selectedKey.downKey || 'Key_S'}" 
                               onchange="updateKeyProp('downKey', this.value)">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â†•ï¸</span>
                            <span>å‘ä¸‹åç§»</span>
                        </div>
                        <input class="property-input" type="number" step="0.01" min="0" max="1" 
                               value="${selectedKey.downOffset || 0.2}" 
                               onchange="updateKeyProp('downOffset', parseFloat(this.value))">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â—€ï¸</span>
                            <span>å‘å·¦é”®</span>
                        </div>
                        <input class="property-input" value="${selectedKey.leftKey || 'Key_A'}" 
                               onchange="updateKeyProp('leftKey', this.value)">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â†”ï¸</span>
                            <span>å‘å·¦åç§»</span>
                        </div>
                        <input class="property-input" type="number" step="0.01" min="0" max="1" 
                               value="${selectedKey.leftOffset || 0.1}" 
                               onchange="updateKeyProp('leftOffset', parseFloat(this.value))">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â–¶ï¸</span>
                            <span>å‘å³é”®</span>
                        </div>
                        <input class="property-input" value="${selectedKey.rightKey || 'Key_D'}" 
                               onchange="updateKeyProp('rightKey', this.value)">
                    </div>
                    <div class="property-group">
                        <div class="property-label">
                            <span class="icon">â†”ï¸</span>
                            <span>å‘å³åç§»</span>
                        </div>
                        <input class="property-input" type="number" step="0.01" min="0" max="1" 
                               value="${selectedKey.rightOffset || 0.1}" 
                               onchange="updateKeyProp('rightOffset', parseFloat(this.value))">
                    </div>
                `;
            }
            
            editor.innerHTML = html;
        }
        
        // æ¸…ç©ºå±æ€§ç¼–è¾‘å™¨
        function clearPropertyEditor() {
            document.getElementById('propertyEditor').innerHTML = `
                <div class="empty-state">
                    <div class="icon">ğŸ…°ï¸</div>
                    <div class="text">é€‰æ‹©ä¸€ä¸ªæŒ‰é”®ä»¥ç¼–è¾‘å±æ€§</div>
                </div>
            `;
        }
        
        // æ›´æ–°é”®æ ‡ç­¾
        function updateKeyLabel(label) {
            if (!selectedKey) return;
            
            selectedKey.label = label;
            
            // æ›´æ–°æ‰€æœ‰ç›¸å…³å…ƒç´ çš„æ˜¾ç¤º
            document.querySelectorAll(`[data-key-id="${selectedKey.id}"] .key-icon`).forEach(icon => {
                if (selectedKey.type === 'KMT_STEER_WHEEL') {
                    icon.textContent = 'æ‘‡æ†';
                } else if (selectedKey.type === 'KMT_SMALL_EYE') {
                    icon.textContent = 'è‡ªç”±è§†è§’';
                } else {
                    const chineseLabels = {
                        'Key_Space': 'ç©ºæ ¼',
                        'Key_Enter': 'å›è½¦',
                        'Key_Tab': 'Tab',
                        'Key_Shift': 'Shift',
                        'Key_Ctrl': 'Ctrl',
                        'Key_Alt': 'Alt',
                        'Key_Escape': 'Esc',
                        'Key_Backspace': 'é€€æ ¼',
                        'LeftButton': 'å·¦é”®',
                        'RightButton': 'å³é”®',
                        'MiddleButton': 'ä¸­é”®',
                        'ForwardButton': 'å‰è¿›',
                        'BackButton': 'åé€€'
                    };
                    
                    if (chineseLabels[selectedKey.key]) {
                        icon.textContent = chineseLabels[selectedKey.key];
                    } else {
                        icon.textContent = label;
                    }
                }
            });
        }
        
        // æ›´æ–°æŒ‰é”®ç¼©æ”¾
        function updateKeyScale(scale) {
            if (!selectedKey) return;
            
            selectedKey.scale = parseFloat(scale);
            
            // ç«‹å³æ›´æ–°æ‰€æœ‰ç›¸å…³å…ƒç´ çš„transform
            document.querySelectorAll(`[data-key-id="${selectedKey.id}"]`).forEach(el => {
                el.style.transform = `translate(-50%, -50%) scale(${selectedKey.scale})`;
            });
            
            // æ›´æ–°ç™¾åˆ†æ¯”æ˜¾ç¤º
            const percentSpan = event.target.nextElementSibling;
            if (percentSpan) {
                percentSpan.textContent = (selectedKey.scale * 100).toFixed(0) + '%';
            }
        }
        
        // æ›´æ–°é”®ç±»å‹
        function updateKeyType(type) {
            if (!selectedKey) return;
            
            const oldType = selectedKey.type;
            selectedKey.type = type;
            
            // å¦‚æœæ˜¯è½¬å‘è½®ï¼Œæ·»åŠ é»˜è®¤å±æ€§
            if (type === 'KMT_STEER_WHEEL') {
                selectedKey.centerPos = {...selectedKey.pos};
                selectedKey.upKey = selectedKey.upKey || 'Key_W';
                selectedKey.downKey = selectedKey.downKey || 'Key_S';
                selectedKey.leftKey = selectedKey.leftKey || 'Key_A';
                selectedKey.rightKey = selectedKey.rightKey || 'Key_D';
                // æ·»åŠ é»˜è®¤offset
                selectedKey.leftOffset = selectedKey.leftOffset || 0.1;
                selectedKey.rightOffset = selectedKey.rightOffset || 0.1;
                selectedKey.upOffset = selectedKey.upOffset || 0.27;
                selectedKey.downOffset = selectedKey.downOffset || 0.2;
            } else if (type === 'KMT_SMALL_EYE') {
                selectedKey.centerPos = {...selectedKey.pos};
                selectedKey.radius = 0.15;
                selectedKey.sensitivity = 1.0;
            }
            
            // é‡æ–°åˆ›å»ºå…ƒç´ 
            document.querySelectorAll(`[data-key-id="${selectedKey.id}"]`).forEach(el => el.remove());
            
            if (type === 'KMT_SMALL_EYE') {
                const pressElement = createMappedKeyElement(selectedKey, 'press');
                canvasContainer.appendChild(pressElement);
            } else if (type === 'KMT_STEER_WHEEL') {
                const pressElement = createMappedKeyElement(selectedKey, 'press');
                canvasContainer.appendChild(pressElement);
            } else {
                const pressElement = createMappedKeyElement(selectedKey, 'press');
                canvasContainer.appendChild(pressElement);
            }
            
            updateMappedKeyPositions(selectedKey);
            selectKey(selectedKey);
        }
        
        // æ›´æ–°é”®ä½ç½®
        function updateKeyPos(axis, value, posType = 'main') {
            if (!selectedKey) return;
            
            const newValue = parseFloat(value);
            
            if (selectedKey.type === 'KMT_SMALL_EYE') {
                if (posType === 'center') {
                    selectedKey.centerPos[axis] = newValue;
                }
            } else if (selectedKey.type === 'KMT_STEER_WHEEL') {
                if (posType === 'main') {
                    selectedKey.centerPos[axis] = newValue;
                }
            } else {
                if (posType === 'main') {
                    selectedKey.pos[axis] = newValue;
                    selectedKey.pressPos[axis] = newValue;
                    selectedKey.releasePos[axis] = newValue;
                }
            }
            
            updateMappedKeyPositions(selectedKey);
            updateConnectionLines();
        }
        
        // æ›´æ–°é”®å±æ€§
        function updateKeyProp(prop, value) {
            if (!selectedKey) return;
            selectedKey[prop] = value;
            
            // å¦‚æœæ˜¯æ‘‡æ†çš„åç§»å€¼æ›´æ–°ï¼Œé‡ç»˜å…«è¾¹å½¢
            if (selectedKey.type === 'KMT_STEER_WHEEL' && 
                ['upOffset', 'downOffset', 'leftOffset', 'rightOffset'].includes(prop)) {
                drawOctagonWheel(selectedKey);
            }
        }
        
        // å®æ—¶æ›´æ–°åæ ‡è¾“å…¥æ¡†çš„å€¼
        function updateCoordinateInputs() {
            if (!selectedKey) return;
            
            if (selectedKey.type === 'KMT_SMALL_EYE') {
                // è‡ªç”±è§†è§’
                const centerXInput = document.querySelector('#propertyEditor input[onchange*="updateKeyPos(\'x\', this.value, \'center\'"]');
                const centerYInput = document.querySelector('#propertyEditor input[onchange*="updateKeyPos(\'y\', this.value, \'center\'"]');
                
                if (centerXInput) centerXInput.value = selectedKey.centerPos.x.toFixed(3);
                if (centerYInput) centerYInput.value = selectedKey.centerPos.y.toFixed(3);
            } else if (selectedKey.type === 'KMT_STEER_WHEEL') {
                // æ‘‡æ†ç±»å‹
                const centerXInput = document.querySelector('#propertyEditor input[onchange*="updateKeyPos(\'x\'"][onchange*="\'main\'"]');
                const centerYInput = document.querySelector('#propertyEditor input[onchange*="updateKeyPos(\'y\'"][onchange*="\'main\'"]');
                if (centerXInput) centerXInput.value = selectedKey.centerPos.x.toFixed(3);
                if (centerYInput) centerYInput.value = selectedKey.centerPos.y.toFixed(3);
            } else {
                // æ›´æ–°ä¸»ä½ç½®è¾“å…¥æ¡†
                const xInput = document.querySelector('#propertyEditor input[onchange*="updateKeyPos(\'x\'"][onchange*="\'main\'"]');
                const yInput = document.querySelector('#propertyEditor input[onchange*="updateKeyPos(\'y\'"][onchange*="\'main\'"]');
                if (xInput) xInput.value = selectedKey.pos.x.toFixed(3);
                if (yInput) yInput.value = selectedKey.pos.y.toFixed(3);
            }
        }
        
        // åˆ é™¤é”®
        function deleteKey(keyId) {
            const index = mappedKeys.findIndex(k => k.id == keyId);
            if (index !== -1) {
                mappedKeys.splice(index, 1);
                
                // åˆ é™¤æ‰€æœ‰ç›¸å…³å…ƒç´ 
                document.querySelectorAll(`[data-key-id="${keyId}"]`).forEach(el => el.remove());
                
                // åˆ é™¤è¿æ¥çº¿
                const line = document.querySelector(`[data-drag-line="${keyId}"]`);
                if (line) line.remove();
                
                if (selectedKey && selectedKey.id == keyId) {
                    selectKey(null);
                }
                
                updateConnectionLines();
            }
        }
        
        // ç»˜åˆ¶ç”»å¸ƒ
        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 10; i++) {
                const x = (canvas.width / 10) * i;
                const y = (canvas.height / 10) * i;
                
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶é¼ æ ‡ç§»åŠ¨åŒºåŸŸï¼ˆç´«è‰²ï¼‰
            if (mouseMoveMap && mouseMoveMap.startPos) {
                // ç»˜åˆ¶åŠé€æ˜ç´«è‰²åŒºåŸŸ
                ctx.fillStyle = 'rgba(115, 79, 154, 0.15)';
                ctx.strokeStyle = 'rgba(115, 79, 154, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                
                const size = 80; // è°ƒæ•´å¤§å°
                const x = mouseMoveMap.startPos.x * canvas.width - size / 2;
                const y = mouseMoveMap.startPos.y * canvas.height - size / 2;
                
                // ç»˜åˆ¶åœ†è§’çŸ©å½¢
                const radius = 8;
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + size - radius, y);
                ctx.quadraticCurveTo(x + size, y, x + size, y + radius);
                ctx.lineTo(x + size, y + size - radius);
                ctx.quadraticCurveTo(x + size, y + size, x + size - radius, y + size);
                ctx.lineTo(x + radius, y + size);
                ctx.quadraticCurveTo(x, y + size, x, y + size - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                
                ctx.fill();
                ctx.stroke();
                ctx.setLineDash([]);
                
                // æ·»åŠ ä¸­å¿ƒç‚¹æ ‡è®°
                ctx.fillStyle = 'rgba(115, 79, 154, 0.8)';
                ctx.beginPath();
                ctx.arc(mouseMoveMap.startPos.x * canvas.width, mouseMoveMap.startPos.y * canvas.height, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // å¯¼å…¥JSON
        function importJSON() {
            document.getElementById('fileInput').click();
        }
        
        // å¤„ç†æ–‡ä»¶å¯¼å…¥
        function handleFileImport(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);
                    loadMapping(data);
                } catch (error) {
                    alert('å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }
        
        // åŠ è½½æ˜ å°„
        function loadMapping(data) {
            clearAll();
            
            const keyMapNodes = data.keyMapNodes || data.KeyMapNodes || [];
            
            keyMapNodes.forEach(node => {
                let keyData;
                
                if (node.type === 'KMT_STEER_WHEEL') {
                    const centerPos = node.centerPos || { x: 0.5, y: 0.5 };
                    keyData = createMappedKey(
                        '',  // æ‘‡æ†ä¸éœ€è¦keyï¼Œä¼ ç©ºå­—ç¬¦ä¸²
                        'æ‘‡æ†', 
                        centerPos.x, 
                        centerPos.y,
                        node.type,
                        {
                            upKey: node.upKey,
                            downKey: node.downKey,
                            leftKey: node.leftKey,
                            rightKey: node.rightKey,
                            centerPos: centerPos,
                            leftOffset: node.leftOffset || 0.1,
                            rightOffset: node.rightOffset || 0.1,
                            upOffset: node.upOffset || 0.27,
                            downOffset: node.downOffset || 0.2,
                            scale: node.scale || 1
                        }
                    );
                } else if (node.type === 'KMT_SMALL_EYE') {
                    keyData = createSmallEye(
                        node.key || 'Key_Space',
                        node.centerPos.x || 0.5,
                        node.centerPos.y || 0.5
                    );
                    keyData.radius = node.radius || 0.15;
                    keyData.sensitivity = node.sensitivity || 1.0;
                } else {
                    const pos = node.pos || { x: 0.5, y: 0.5 };
                    keyData = createMappedKey(
                        node.key,
                        node.key.replace('Key_', '').replace('Button', ''),
                        pos.x,
                        pos.y,
                        node.type || 'KMT_CLICK',
                        {
                            resetMove: node.resetMove,
                            switchMap: node.switchMap,
                            showMouse: node.showMouse,
                            resetView: node.resetView,
                            scale: node.scale || 1
                        }
                    );
                }
            });
            
            if (data.mouseMoveMap) {
                mouseMoveMap = data.mouseMoveMap;
                // ç¡®ä¿æœ‰é»˜è®¤å€¼
                if (!mouseMoveMap.key) mouseMoveMap.key = 'Key_QuoteLeft';
                if (!mouseMoveMap.speedRatioX) mouseMoveMap.speedRatioX = 1;
                if (!mouseMoveMap.speedRatioY) mouseMoveMap.speedRatioY = 1;
                drawCanvas();
            }
            
            if (data.switchKey) {
                switchKey = data.switchKey;
                switchKeyPos = data.switchKeyPos || { x: 0.501, y: 0.501 };
            }
        }
        
        // å¯¼å‡ºJSON
        function exportJSON() {
            const data = {
                keyMapNodes: [],
                mouseMoveMap: mouseMoveMap,
                switchKey: switchKey,
                switchKeyPos: switchKeyPos
            };
            
            // å¤„ç†å…¶ä»–æŒ‰é”®
            mappedKeys.forEach(key => {
                const node = {
                    key: key.key,
                    type: key.type,
                    scale: key.scale || 1
                };
                
                if (key.type === 'KMT_STEER_WHEEL') {
                    // åˆ é™¤keyå±æ€§
                    delete node.key;
                    node.comment = "æ‘‡æ†";
                    node.centerPos = key.centerPos || key.pos;
                    node.leftOffset = key.leftOffset || 0.1;
                    node.rightOffset = key.rightOffset || 0.1;
                    node.upOffset = key.upOffset || 0.27;
                    node.downOffset = key.downOffset || 0.2;
                    node.leftKey = key.leftKey || 'Key_A';
                    node.rightKey = key.rightKey || 'Key_D';
                    node.upKey = key.upKey || 'Key_W';
                    node.downKey = key.downKey || 'Key_S';
                } else if (key.type === 'KMT_SMALL_EYE') {
                    node.comment = "è‡ªç”±è§†è§’";
                    node.centerPos = key.centerPos;
                    node.radius = key.radius || 0.15;
                    node.sensitivity = key.sensitivity || 1.0;
                } else {
                    node.pos = key.pos;
                    node.resetMove = key.resetMove || false;
                    node.switchMap = key.switchMap || false;
                    node.showMouse = key.showMouse || false;
                    node.resetView = key.resetView || false;
                }
                
                data.keyMapNodes.push(node);
            });
            
            // é¼ æ ‡ç§»åŠ¨æ˜ å°„
            if (mouseMoveMap && mouseMoveMap.startPos) {
                data.mouseMoveMap = {
                    startPos: mouseMoveMap.startPos,
                    speedRatioX: mouseMoveMap.speedRatioX || 3.25,
                    speedRatioY: mouseMoveMap.speedRatioY || 1.25,
                    speedRatio: 10,
                    smallEyes: {  // ç›´æ¥ä½œä¸ºå¯¹è±¡ï¼Œä¸æ˜¯ä»¥keyä¸ºç´¢å¼•
                        comment: "å°çœ¼ç›",
                        type: "KMT_CLICK", 
                        key: mouseMoveMap.smallEyeKey || 'Key_Alt',
                        pos: mouseMoveMap.smallEyePos || { x: 0.5, y: 0.6 },
                        switchMap: false
                    }
                };
            } else {
                // é»˜è®¤é¼ æ ‡ç§»åŠ¨æ˜ å°„
                data.mouseMoveMap = {
                    startPos: { x: 0.5, y: 0.5 },
                    speedRatioX: 3.25,
                    speedRatioY: 1.25,
                    smallEyes: {
                        comment: "å°çœ¼ç›",
                        type: "KMT_CLICK", 
                        key: 'Key_Alt',
                        pos: { x: 0.5, y: 0.6 },
                        switchMap: false
                    }
                };
            }
            
            const jsonStr = JSON.stringify(data, null, 4);
            document.getElementById('jsonOutput').textContent = jsonStr;
            document.getElementById('savePathInput').value = savePath; // æ˜¾ç¤ºå½“å‰ä¿å­˜è·¯å¾„
            document.getElementById('scriptNameInput').value = scriptName; // æ˜¾ç¤ºå½“å‰è„šæœ¬åç§°
            document.getElementById('exportModal').classList.add('show');
        }
        
        // å¤åˆ¶JSON
        function copyJSON() {
            const jsonText = document.getElementById('jsonOutput').textContent;
            navigator.clipboard.writeText(jsonText).then(() => {
                alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            });
        }
        
        // ä¸‹è½½JSON
        function downloadJSON() {
            const jsonText = document.getElementById('jsonOutput').textContent;
            // ä½¿ç”¨scriptNameä½œä¸ºæ–‡ä»¶å
            const filename = scriptName;
            const blob = new Blob([jsonText], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            alert(`å·²ä¿å­˜åˆ°ä¸‹è½½ç›®å½•ï¼š${filename}`);
        }
        
        // è®¾ç½®ä¿å­˜è·¯å¾„
        function setSavePath() {
            const pathInput = document.getElementById('savePathInput');
            savePath = pathInput.value;
            localStorage.setItem('qtscrcpy_save_path', savePath);
            alert(`ä¿å­˜è·¯å¾„å·²æ›´æ–°ä¸ºï¼š${savePath}`);
        }
        
        // è®¾ç½®è„šæœ¬åç§°
        function setScriptName() {
            const nameInput = document.getElementById('scriptNameInput');
            scriptName = nameInput.value.trim() || 'keymap.json';
            localStorage.setItem('qtscrcpy_script_name', scriptName);
            alert(`è„šæœ¬åç§°å·²æ›´æ–°ä¸ºï¼š${scriptName}`);
        }
        
        // å…³é—­æ¨¡æ€æ¡†
        function closeModal() {
            document.getElementById('exportModal').classList.remove('show');
        }
        
        // æ¸…ç©ºæ‰€æœ‰
        function clearAll() {
            mappedKeys = [];
            selectedKey = null;
            mouseMoveMap = null;
            
            document.querySelectorAll('.mapped-key').forEach(el => el.remove());
            connectionSvg.innerHTML = '';
            clearPropertyEditor();
            drawCanvas();
        }
        
        // ç¼–è¾‘é¼ æ ‡ç§»åŠ¨æ˜ å°„
        function editMouseMove() {
            const modal = document.getElementById('mouseMoveModal');
            
            if (mouseMoveMap) {
                document.getElementById('mouseMoveStartX').value = mouseMoveMap.startPos?.x || 0.5;
                document.getElementById('mouseMoveStartY').value = mouseMoveMap.startPos?.y || 0.5;
                document.getElementById('mouseMoveSpeedX').value = mouseMoveMap.speedRatioX || 3.25;
                document.getElementById('mouseMoveSpeedY').value = mouseMoveMap.speedRatioY || 1.25;
                document.getElementById('mouseMoveSpeedXSlider').value = mouseMoveMap.speedRatioX || 3.25;
                document.getElementById('mouseMoveSpeedYSlider').value = mouseMoveMap.speedRatioY || 1.25;
                document.getElementById('mouseMoveTimedReset').checked = mouseMoveMap.timedResetView || false;
                document.getElementById('mouseMoveKey').value = mouseMoveMap.key || 'Key_QuoteLeft';
                document.getElementById('smallEyeKey').value = mouseMoveMap.smallEyeKey || 'Key_Alt';
                document.getElementById('smallEyePosX').value = mouseMoveMap.smallEyePos?.x || 0.5;
                document.getElementById('smallEyePosY').value = mouseMoveMap.smallEyePos?.y || 0.6;
            } else {
                // è®¾ç½®é»˜è®¤å€¼
                document.getElementById('mouseMoveStartX').value = 0.5;
                document.getElementById('mouseMoveStartY').value = 0.5;
                document.getElementById('mouseMoveSpeedX').value = 3.25;
                document.getElementById('mouseMoveSpeedY').value = 1.25;
                document.getElementById('mouseMoveSpeedXSlider').value = 3.25;
                document.getElementById('mouseMoveSpeedYSlider').value = 1.25;
                document.getElementById('mouseMoveKey').value = 'Key_QuoteLeft';
                document.getElementById('smallEyeKey').value = 'Key_Alt';
                document.getElementById('smallEyePosX').value = 0.5;
                document.getElementById('smallEyePosY').value = 0.6;
            }
            
            modal.classList.add('show');
        }
        
        // ä¿å­˜é¼ æ ‡ç§»åŠ¨æ˜ å°„
        function saveMouseMove() {
            mouseMoveMap = {
                startPos: {
                    x: parseFloat(document.getElementById('mouseMoveStartX').value),
                    y: parseFloat(document.getElementById('mouseMoveStartY').value)
                },
                speedRatioX: parseFloat(document.getElementById('mouseMoveSpeedX').value),
                speedRatioY: parseFloat(document.getElementById('mouseMoveSpeedY').value),
                timedResetView: document.getElementById('mouseMoveTimedReset').checked,
                key: document.getElementById('mouseMoveKey').value || 'Key_QuoteLeft',
                smallEyeKey: document.getElementById('smallEyeKey').value || 'Key_Alt',
                smallEyePos: {
                    x: parseFloat(document.getElementById('smallEyePosX').value),
                    y: parseFloat(document.getElementById('smallEyePosY').value)
                }
            };
            
            // è‡ªåŠ¨åˆ›å»ºå°çœ¼ç›æŒ‰é”®
            if (mouseMoveMap.smallEyeKey && mouseMoveMap.smallEyeKey !== '') {
                const existingKey = mappedKeys.find(k => k.key === mouseMoveMap.smallEyeKey);
                if (!existingKey) {
                    createMappedKey(
                        mouseMoveMap.smallEyeKey,
                        'å°çœ¼ç›',
                        mouseMoveMap.smallEyePos.x,
                        mouseMoveMap.smallEyePos.y,
                        'KMT_CLICK',
                        {
                            scale: 0.8,
                            showMouse: true,
                            resetView: true
                        }
                    );
                }
            }
            
            drawCanvas();
            closeMouseMoveModal();
        }
        
        // å…³é—­é¼ æ ‡ç§»åŠ¨æ˜ å°„æ¨¡æ€æ¡†
        function closeMouseMoveModal() {
            document.getElementById('mouseMoveModal').classList.remove('show');
        }
        
        // æ›´æ–°ç”»å¸ƒç¼©æ”¾
        function updateCanvasZoom(zoom) {
            const zoomValue = parseInt(zoom);
            document.getElementById('zoomValue').textContent = zoomValue + '%';
            
            const scale = zoomValue / 100;
            canvasContainer.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
        
        // è°ƒæ•´ç¼©æ”¾
        function adjustZoom(delta) {
            const zoomSlider = document.getElementById('canvasZoom');
            const currentZoom = parseInt(zoomSlider.value);
            const newZoom = Math.max(25, Math.min(150, currentZoom + delta));
            zoomSlider.value = newZoom;
            updateCanvasZoom(newZoom);
        }
        
        // åº”ç”¨é¢„è®¾åˆ†è¾¨ç‡
        function applyPresetResolution(preset) {
            if (!preset) return;
            
            const [width, height] = preset.split('x').map(v => parseInt(v));
            document.getElementById('canvasWidth').value = width;
            document.getElementById('canvasHeight').value = height;
            updateCanvasResolution();
        }
        
        // æ·»åŠ æ‘‡æ†
        function addSteeringWheel() {
            const wheelType = confirm('é€‰æ‹©æ‘‡æ†ç±»å‹ï¼š\nç¡®å®š - WASDæ‘‡æ†\nå–æ¶ˆ - æ–¹å‘é”®æ‘‡æ†');
            
            const config = wheelType ? {
                upKey: 'Key_W',
                downKey: 'Key_S', 
                leftKey: 'Key_A',
                rightKey: 'Key_D'
            } : {
                upKey: 'Key_Up',
                downKey: 'Key_Down',
                leftKey: 'Key_Left',
                rightKey: 'Key_Right'
            };
            
            createMappedKey('', 'æ‘‡æ†', 0.5, 0.5, 'KMT_STEER_WHEEL', config);
        }
        
        // åˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>
